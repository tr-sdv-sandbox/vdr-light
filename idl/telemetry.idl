// Copyright 2025 VDR-Light Contributors
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// @file telemetry.idl
/// @brief DDS IDL definitions for VDR ecosystem
///
/// Defines message types for onboard telemetry transport.
/// These are optimized for onboard use - cloud enrichment happens at ingestion.

module telemetry {

    /*
     * Common header for all messages.
     * Provides tracing, ordering, and correlation.
     */
    struct Header {
        string source_id;
        long long timestamp_ns;
        unsigned long seq_num;
        string correlation_id;
    };

    /*
     * Key-value pair for labels/fields.
     */
    struct KeyValue {
        string key;
        string value;
    };

    /*
     * VSS (Vehicle Signal Specification) signals.
     */
    module vss {

        enum Quality {
            QUALITY_NOT_AVAILABLE,
            QUALITY_VALID,
            QUALITY_INVALID
        };

        enum ValueType {
            VALUE_TYPE_BOOL,
            VALUE_TYPE_INT32,
            VALUE_TYPE_INT64,
            VALUE_TYPE_FLOAT,
            VALUE_TYPE_DOUBLE,
            VALUE_TYPE_STRING
        };

        /*
         * A single VSS signal sample.
         */
        struct Signal {
            string path;
            telemetry::Header header;
            Quality quality;
            ValueType value_type;
            boolean bool_value;
            long int32_value;
            long long int64_value;
            float float_value;
            double double_value;
            string string_value;
        };
        #pragma keylist Signal path

    };

    /*
     * Vehicle events.
     */
    module events {

        enum Severity {
            SEVERITY_INFO,
            SEVERITY_WARNING,
            SEVERITY_ERROR,
            SEVERITY_CRITICAL
        };

        /*
         * A vehicle event.
         */
        struct Event {
            string event_id;
            telemetry::Header header;
            string category;
            string event_type;
            Severity severity;
            sequence<octet> payload;
        };
        #pragma keylist Event event_id

    };

    /*
     * Diagnostic measurements.
     */
    module diagnostics {

        enum MeasurementType {
            MEASUREMENT_TYPE_ACCUMULATED,
            MEASUREMENT_TYPE_MOMENTARY
        };

        /*
         * Scalar diagnostic measurement.
         */
        struct ScalarMeasurement {
            string variable_id;
            telemetry::Header header;
            string unit;
            MeasurementType mtype;
            double value;
        };
        #pragma keylist ScalarMeasurement variable_id

        /*
         * Vector diagnostic measurement.
         */
        struct VectorMeasurement {
            string variable_id;
            telemetry::Header header;
            string unit;
            MeasurementType mtype;
            sequence<double> values;
        };
        #pragma keylist VectorMeasurement variable_id

    };

    /*
     * Prometheus-style telemetry metrics.
     */
    module metrics {

        /*
         * Counter metric (cumulative, only increases).
         */
        struct Counter {
            string name;
            telemetry::Header header;
            sequence<telemetry::KeyValue> labels;
            double value;
        };
        #pragma keylist Counter name

        /*
         * Gauge metric (can go up or down).
         */
        struct Gauge {
            string name;
            telemetry::Header header;
            sequence<telemetry::KeyValue> labels;
            double value;
        };
        #pragma keylist Gauge name

        /*
         * Histogram bucket.
         */
        struct HistogramBucket {
            double upper_bound;
            unsigned long long cumulative_count;
        };

        /*
         * Histogram metric.
         */
        struct Histogram {
            string name;
            telemetry::Header header;
            sequence<telemetry::KeyValue> labels;
            unsigned long long sample_count;
            double sample_sum;
            sequence<HistogramBucket> buckets;
        };
        #pragma keylist Histogram name

    };

    /*
     * IEEE 1722 AVTP transport messages.
     * Used for CAN/LIN/FlexRay tunneling over Ethernet (MCU <-> HPC).
     */
    module avtp {

        /*
         * AVTP frame type indicators.
         */
        enum AcfType {
            ACF_TYPE_CAN,
            ACF_TYPE_CAN_BRIEF,
            ACF_TYPE_LIN,
            ACF_TYPE_FLEXRAY,
            ACF_TYPE_SENSOR,
            ACF_TYPE_GPC
        };

        /*
         * CAN frame flags.
         */
        struct CanFlags {
            boolean is_extended_id;   /* Extended (29-bit) vs standard (11-bit) ID */
            boolean is_fd;            /* CAN-FD frame */
            boolean is_brs;           /* Bit rate switch (CAN-FD) */
            boolean is_esi;           /* Error state indicator (CAN-FD) */
            boolean is_rtr;           /* Remote transmission request */
        };

        /*
         * ACF CAN frame - CAN message encapsulated in AVTP.
         * Maps to IEEE 1722 ACF CAN PDU.
         */
        struct AcfCanFrame {
            telemetry::Header header;
            unsigned long long stream_id;     /* AVTP stream identifier */
            unsigned long can_id;             /* CAN arbitration ID */
            octet bus_id;                     /* CAN bus identifier (0-31) */
            CanFlags flags;
            sequence<octet, 64> payload;      /* CAN data (up to 64 bytes for CAN-FD) */
            unsigned long long avtp_timestamp; /* AVTP presentation timestamp */
            unsigned long sequence_num;       /* AVTP sequence number */
        };
        #pragma keylist AcfCanFrame stream_id can_id

        /*
         * Batch of CAN frames for efficiency.
         * TSCF (Time-Synchronous Control Format) can carry multiple ACF messages.
         */
        struct AcfCanBatch {
            telemetry::Header header;
            unsigned long long stream_id;
            sequence<AcfCanFrame> frames;
        };
        #pragma keylist AcfCanBatch stream_id

        /*
         * AVTP stream statistics for monitoring.
         */
        struct StreamStats {
            telemetry::Header header;
            unsigned long long stream_id;
            unsigned long long frames_received;
            unsigned long long frames_sent;
            unsigned long long sequence_errors;
            unsigned long long timestamp_errors;
            unsigned long long bytes_total;
            double average_latency_us;
        };
        #pragma keylist StreamStats stream_id

    };

    /*
     * Log entries.
     */
    module logs {

        enum Level {
            LEVEL_DEBUG,
            LEVEL_INFO,
            LEVEL_WARN,
            LEVEL_ERROR
        };

        /*
         * A log entry.
         */
        struct LogEntry {
            telemetry::Header header;
            Level level;
            string component;
            string message;
            sequence<telemetry::KeyValue> fields;
        };
        #pragma keylist LogEntry

    };

};
